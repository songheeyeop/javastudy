# 03 데이터 모델링
- 엘라스틱서치에서는 색인할 때 문서의 데이터 유형에 따라 필드에 적절한 데이터 타입을 지정해야 한다. = 매핑 = 색인될 문서의 데이터 모델링 = 중요함
- 이번 장에서는 엘라스틱서치에서 제공하는 데이터 모델링 방법에 대해 알아보자

## 3.1 매핑 API 이해하기
- 매핑 = 색인 시 데이터가 어디에 어떻게 저장될지 결정하는 설정
- 데이터베이스의 스키마에 대응하는 개념
- 문서에 존재하는 필드의 속성을 정의할 때 각 필드 속성에는 데이터 타입과 메타데이터가 포함된다.
  - 이를 통해 색인 과정에서 문서가 어떻게 역색인으로 변호나되는지를 상세하게 정의함.
- DB에서 테이블의 컬럼 정보를 정의하는 것이 중요하듯 엘라스틱서치에서도 데이터의 타입을 정의하는 것은 매우 중요하다.
- 엘라스틱서치는 기본적으로 스키마리스이기 때문에 명시적으로 필드를 정의하지 않아도 데이터 유형에 따라 필드 데이터 타입에 대한 매핑 정보가 자동으로 생성된다.
- 실수로 타입 잘못 지정지 수정할 방법이 없으므로 주의해야 한다.
- 예제 
~~~
# 문서 1
{
  "movieCd" : "20173732",
  "movieNm" : "캡틴 아메리카"
}

# 문서 2
{
  "movieCd" : "XT001",
  "movieNm" : "아이언맨"
}
~~~
- 첫 번째 문서를 매핑 설정 없이 색인하면 movieCd 필드는 숫자 타입으로 매핑되고, movieNm은 문자 타입으로 매핑된다.
- 두 번째 문서 색인시 실패(movieCd 숫자 타입으로 매핑되었으므로)
- 동적 매핑을 하면 문서에 새로운 필드가 추가될 때마다 인덱스가 자동으로 업데이트되기 때문에 쉽고 편리하지만 한 번 정의된 필드에 서로 다른 타입의 데이터가 입력된다면 뒤에 입력된 데이터의 색인 생성에 실패한다.
- 매핑 정보를 설정할 때는 다음과 같은 사항을 고민해야 한다.

~~~
문자열을 분석할 것인가?
_source 에 어떤 필드를 정의할 것인가?
날짜 필드를 가지는 필드는 무엇인가?
매핑에 정의되지 않고 유입되는 필드는 어떻게 처리할것인가?
~~~
- 앞으로는 인덱스를 생성할 때 항상 명시적인 매핑 설정을 사용하자

### 3.1.1 매핑 인덱스 만들기
- 인덱스 매핑 목록 예시
- 표 3.1 영화 정보 문서의 구조

  |   매핑명    |         필드명         |       필드 타입       |
  |:--------:|:-------------------:|:-----------------:|
  |   인덱스키   |       moiveCd       |      keyword      |
  | 영화제목_국문  |       movieNm       |       text        |
  | 영화제목_영문  |      movieNmEn      |       text        |
  |   제작연도   |      prdtYear       |      integer      |
  |   개봉연도   |       openDt        |      integer      |
  |   영화유형   |       typeNm        |      keyword      |
  |   제작상태   |     prdtStatNm      |      keyword      |
  | 제작국가(전체) |      nationAlt      |      keyword      |
  |  장르(전체)  |      genreAlt       |      keyword      |
  | 대표 제작국가  |     repNationNm     |      keyword      |
  |   재표장르   |     repGenreNm      |      keyword      |
  |  영화감독명   | directors.peopleNm  | object -> keyword |
  |  제작사코드   | companies.companyCd | object -> keyword |
  |   제작사명   | companies.companyNm | object -> keyword |

- 색인할 실제 데이터는 다음과 같은 정보로 구성돼 있다.
~~~
{
  "movieCd":"20173732",
  "movieNm":"살아남은 아이",
  "movieNmEn":"Last Child",
  "prdtYear":"2017",
  "openDt":"",
  "typeNm":"장편",
  "prdtStatNm":"기타",
  "nationAlt":"한국",
  "genreAlt":"드라마, 가족",
  "repNationNm":"한국",
  "repGenreNm":"드라마",
  "directors":[{
    "peopleNm":"신동석"
  }],
  "companies": [
    "companyCd":"",
    "companyNm":""
  ]
}
~~~
- 실제 검색 대상이 되는 필드는 "영화제목" 필드이므로 분석 가능하도록 text 타입으로 정의한다.
- keyword 타입이랑 text 타입의 차이??(varchar2와 clob 차이??)
- 다음과 같이 인덱스 설정
~~~
PUT movie_search
{
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  },
  "mappings": {
    "properties": {
      "moiveCd":{
        "type": "keyword"
      },
      "movieNm":{
        "type": "text"
      },
      "moiveNmEn":{
        "type": "text"
      },
      "prdtYear":{
        "type": "integer"
      },
      "openDt":{
        "type": "integer"
      },
      "typeNm":{
        "type": "keyword"
      },
      "prdtStatNm":{
        "type": "keyword"
      },
      "nationAlt":{
        "type": "keyword"
      },
      "genreAlt":{
        "type": "keyword"
      },
      "repNationNm":{
        "type": "keyword"
      },
      "repGenreNm":{
        "type": "keyword"
      },
      "directors": {
        "properties": {
          "peopleNm": {
            "type": "keyword"
          }
        }
      },
      "companies": {
        "properties": {
          "companyCd": {
            "type": "keyword"
          },
          "companyNm": {
            "type": "keyword"
          }
        }
      }
    }
  }
}

인덱스 결과
{
  "acknowledged" : true,
  "shards_acknowledged" : true,
  "index" : "movie_search"
}
~~~

### 3.1.2 매핑 확인
- 인덱스 매핑 정보 
~~~
GET movie_search/_mapping

실행 결과
{
  "movie_search" : {
    "mappings" : {
      "properties" : {
        "companies" : {
          "properties" : {
            "companyCd" : {
              "type" : "keyword"
            },
            "companyNm" : {
              "type" : "keyword"
            }
          }
        },
        "directors" : {
          "properties" : {
            "peopleNm" : {
              "type" : "keyword"
            }
          }
        },
        "genreAlt" : {
          "type" : "keyword"
        },
        "moiveCd" : {
          "type" : "keyword"
        },
        "moiveNmEn" : {
          "type" : "text"
        },
        "movieNm" : {
          "type" : "text"
        },
        "nationAlt" : {
          "type" : "keyword"
        },
        "openDt" : {
          "type" : "integer"
        },
        "prdtStatNm" : {
          "type" : "keyword"
        },
        "prdtYear" : {
          "type" : "integer"
        },
        "repGenreNm" : {
          "type" : "keyword"
        },
        "repNationNm" : {
          "type" : "keyword"
        },
        "typeNm" : {
          "type" : "keyword"
        }
      }
    }
  }
}
~~~
### 3.1.3 매핑 파라미터
- 매핑파라미터는 색인할 필드의 데이터를 어떻게 저장할지에 대한 다양한 옵션 제공
- analyzer
  - 해당 필드의 데이터를 형태소 분석하겠다는 의미의 파라미터.
  - 색인과 검색 시 지정한 분석기로 형태소 분석을 수행한다.
  - text 데이터 타입의 필드는 analyzer 매핑 파라미터를 기본적으로 사용한다.
  - 별도의 분석기를 지정하지 않으면 Standard Analyzer로 형태소 분석을 수행한다.
- nomalizer
  - nomalizer 매핑 파라미터는 term query에 분석기를 사용하기 위해 사용
  - 예를 들어 keyword 데이터 타입의 경우 원문을 기준으로 분서가 색인되기 cafe, Cafe, Café는 서로 다른 문서로 인식된다. 
  - 해당 유형을 nomalizer를 통해 asciifolding과 같은 필터를 사용하면 같은 데이터로 인식되게 할 수 있다.
- boost
  - 필드에 가중치를 부여한다. 가중치에 따라 유사도 점수(_score)가 달라지기 때문에 boost 설정 시 검색 결과의 노출 순서에 영향을 준다.
  - 색인 시점에 boost 설정을 하게 된다면 재색인하지 않는 이상 가중치 변경을 할 수 없기 때문에 주의해서 사용해야 한다.(가급적 검색시점에먼 사용 권장)
  - 최신 엘라스틱서치는 boost 설정을 할 수 없도록 바뀜.
- coerce
  - 색인 시 자동 변환을 허용할 지 여부를 설정하는 파라미터.
  - 10과 같은 형태의 문자열이 integer 타입의 필드에 들어온다면 엘라스틱서치는 자동으로 형변홚을 수행
  - coerce설정을 미사용으로 변경한다면 색인 실패
- copy_to
  - 매핑 파라미터를 추가한 필드의 값을 지정한 필드로 복사한다.
  - keyword 타입의 필드에 copy_to 매핑 파라미터를 사용해 다른 필드로 값을 복사하면 복사된 필드에서는 text 타입을 지정해 형태소 분석을 할 수도 있다.
  - 여러개의 필드 데이터를 하나의 필드에 모아서 전체 검색 용도로 사용하기도 한다.
  - _all 칼럼과 동일한 기능
  - ex) 다음과 같은 문서가 색인됐다고 가정해보자.
~~~
{
  "movieCd":"20173732",
  "movieNm":"살아남은 아이",
  "movieNmEn":"Last Child"
}
~~~
- 
  - copy_to 파라미터를 이용하면 movieNm과 movieNmEn의 결과를 합해서 "살아남은 아이 Last Child"라는 데이터를 저장하는 필드를 생성할 수 있다.
- fielddata
  - fielddata는 엘라스틱서치가 힙 공간에 생성하는 메모리 캐시다. 과거에는 feilddata를 많이 사용했지만 반복적인 메모리 부족 현상과 잦은 GC로 현재는 거의 사용되지 않는다.
  - 최신 버전의 엘라스틱서치는 doc_values라는 새로운 형태의 캐시를 제공하고 있으며, text 타입의 필드를 제외한 모든 필드는 기본적으로 doc_values 캐시를 사용한다.
  - fielddata를 사용해야만 하는 경우도 있다.
  - text 타입의 필드는 기본적으로 분석기에 의해 형태소 분석이 되기 때문에 집계나 정렬 등의 기능을 수행할 수 없다. 
  - fielddata는 메모리에 생성되는 캐시이기 떄문에 최소한만으로 사용해야 한다.
  - fielddata는 메모리 소모가 크기 때문에 기본적으로 비활성화.
~~~
PUT movie_search_mapping/_mapping/_doc
{
  "propreties": {
    "nationAltEn" : {
      "type":"text",
      "fielddata":true
    }
  }
}
~~~
- doc_value
  - 엘라스틱서치에서 사용하는 기본 캐시.
  - text타입을 제외한 모든 타입에서 기본적으로 doc_value캐시를 사용
  - GC의 비용이 들지 않으면서도 메모리 연산과 비슷한 성능을 보여준다.
  - 필드를 정렬, 집계할 필요가 없고 스크립트에서 필드 값에 액세스할 필요가 없다면 디스크 공간을 절약하기 위해 doc_value를 비활성화할 수도 있다. 
  - 한 번 비활성화된 필드는 인덱스를 재색인하지 않는 한 변경이 불가능하다
- dynamic
  - 매핑에 필드를 추가할 때 동적으로 생성할지, 생서하지 않을지를 결정한다.
  - 동적 생성 
~~~
1. true - 새로 추가되는 필드를 매핑에 추가한다.
2. false - 새로 추가되는 필드를 무시한다. 해당 필드는 색인되지 않아 검색할 수 없지만 _source에는 표시된다.
3. strict - 새로운 필드가 감지되면 예외가 발생하고 문서 자체가 색인되지 않는다. 새로 유입되는 필드는 사용자가 매핑에 명시적으로 추가해야 한다.
~~~
- enabled
  - 검색 결과에는 포함하지만 색인은 하고 싶지 않은 경우에 사용
  - ex) 일반적인 게시판이라면 제목과 요약 글만 색인하고 날짜와 사용자 ID는 색인하지 않는 경우
  - 색인을 원치 않는 날짜와 사용자 ID의 매핑 파라미터 중 enabled를 false로 설정하면 _source에는 검색이 되지만 색인은 하지 않는다.
- format
  - 엘라스틱서치는 날짜/시간을 문자열로 표시한다. 이때 날짜/시간을 문자열로 변경할 대 미리 구성된 포맷을 사용할 수 있다.
  
    |                                    포맷                                     |            날짜 형식            |          비고           |
    |:-------------------------------------------------------------------------:|:---------------------------:|:---------------------:|
    |                                basic_date                                 |          yyyyMMdd           |        년도/월/일         |
    |                              basic_date_time                              |    yyyMMdd'T'HHmmss.SSSZ    | 년도/월/일/T/시/분/초/밀리초/Z  |
    |                                basic_time                                 |         HHmmss.SSS          |      시/분/초/밀리초/Z      |
    |                             date/strict_date                              |         yyyy-MM-dd          |        년도/월/일         |
    |        date_hour_minute_second/<br/>strict_date_hour_minute_second        |   yyyy-MM-dd'T'HH:mm:ss.    |    년도/월/일/T/시/분/초     |
    | date_hour_minute_second_millis/<br/>strict_date_hour_minute_second_millis | yyyy-MM-dd'T'HH:mm:ss.SSS.  |  년도/월/일/T/시/분/초/밀리초   |
    |                        date_time/strict_date_time                         | yyyy-MM-dd'T'HH:mm:ss.SSSZZ | 년도/월/일/T/시/분/초/밀리초/ZZ |

- ignore_above
  - 필드에 저장되는 문자열이 지정한 크기를 넘어서면 빈 값으로 색인한다. 지정한 크기만큼만 색인되는 것이 아니라 빈 값으로 저장되므로 주의해야 한다.
- ignore_malformed 
  - 엘라스틱서치에서는 잘못된 데이터 타입을 색인하려고 하면 예외가 발생하고 해당 문서 전체가 색인되지 않는다. 이 매핑 파라미터를 사용하면 해당 필드만 무시하고 문서는 색인할 수 있다.
- index
  - index 매핑 파라미터는 필득밧을 색인할지를 결정한다. 기본 값은 true이며 false로 변경하면 해당 필드를 색인하지 않는다.
- fields
  - 다중 필드를 설정할 수 있는 옵션이다. 필드 안에 또 다른 필드의 정보를 추가할 수 있어 같은 string값을 각각 다른 분석기로 처리하도록 설정할 수 있다.
  - 다음과 같이 기본 필드는 전문 검색을 하고 필드 안의 추가 필드는 집계용으로 사용할 수 있다.
~~~
PUT movie_search_mapping
{
  "mappings": {
    "properties": {
      "awards":{
        "type": "text",
        "fields": {
          "name": {
            "type" : "keyword"
          }
        }
      }
    }
  }
}
~~~
- norms 
  - 문서의 _score 값 계산에 필요한 정규화 인수를 사용할지 여부를 설정한다. 기본값은 true
  - _score계산이 필요 없거나 단순 필터링 용도로 사용하는 필드는 비활성화해서 디스크 공간을 절약할 수 있다.
- null_value
  - 엘라스틱서치는 색인 시 문서에 필드가 없거나 필드의 값이 null이면 색인 시 필드를 생성하지 않는다.
  - 이 경우 null_value를 설정하면 문서의 값이 null이더라도 필드를 생성하고 그에 해당하는 값으로 저장한다.
~~~
PUT movie_search_mapping/_mapping
{
  "properties": {
    "audiCnt": {
      "type": "integer",
      "null_value": "0"
    }
  }
}
~~~
- position_increment_gap
  - 배열 형태의 데이터를 색인할 때 검색의 정확도를 높이기 위해 제공하는 옵션이다. 필드 데이터 중 단어와 단어 사이에 간격(slop)을 허용할지를 설정한다. 
  - 검색 시 단어와 단어 사이의 간격을 기준으로 일치하는 문서를 찾는 데 필요하다. 
  - 예를 들어 데이터가 ["John Abraham", "Lincon Smith"] 일때 "Abraham Lincon" 으로도 검색이 가능하다.
- properties
  - 오브젝트 타입이나 중첩 타입의 스키마를 정의할 때 사용되는 옵션으로 필드의 타입을 매핑한다. 
  - 오브텍트 필드 및 중첩 필드에는 properties라는 서브 필드가 있다. 이 properties는 object나 nested 를 포함한 모든 데이터 타입이 될 수 있다.
- search_analyzer
  - 일반적으로 색인과 검색 시 같은 분석기를 사용한다. 만약 다른 분석기를 사용하고 싶은 경우 search_analyzer를 설정해서 검색 시 사용할 분석기를 별도로 지정할 수 있다.
- similarity
  - 유사도 측정 알고리즘을 지정한다.
  - 유사도 측정 방식을 기본 알고리즘인 BM25에서 다른 알고리즘으로 변경할 수 있다.
  - 표 3.4 미리 정의돼 있는 유사도 측정 알고리즘.

|  알고리즘   |                                                             설명                                                             | 
|:-------:|:--------------------------------------------------------------------------------------------------------------------------:|
|  BM25   |                                        Okapi BM25 알고리즘이다. 엘라스틱서치의 기본 유사도 측정 알고리즘이다.                                        |
| classic |                                   TF/IDF 알고리즘이다. 문서 내 용어의 개수와 전체 용어의 개수를 이용해 유사도를 계산한다.                                    |
| boolean | 복잡한 수학적 모델을 사용하지 않고 단순히 boolean 연산으로 유사도를 측정한다. score는 검색어 일치 여부에 따라결정되며,<br/>검색 결과의 일치여부에 따라 쿼리의 가중치에 사용된 점수로만 유사도를 계산한다. |

- store 
  - 필드의 값을 저장해 검색 결과에 값을 포함하기 위한 매핑 파라미터다. 기본적으로 엘라스틱서치에서는 _source에 색인된 문서가 저장. 
  - store 매핑 파라미터를 사용하면 해당 필들르 자체적으로 저장할 수 있다. 
  - ex) 10개의 필드가 존재하고 해당 필드에 데이터를 매핑한 상태라면 _source를 로드해서 해당 필드를 찾는 것보다 사용할 각 필드만 로드해서 사용하는 편이 효율적.
  - 하지만 해당 매핑 파라미터를 사용하면 디스크를 더 많이 사용한다
- team_vector
  - 루씬에서 분석한 용어의 정보를 포함할지 여부를 결정하는 매핑 파라미터.
  - 표 3.5 term_vector 설정 가능한 매핑 파라미터 인자.


|           인자            |                 설명                 | 
|:-----------------------:|:----------------------------------:|
|           no            |           텀벡터를 저장하지 않는다.           |
|           yes           |           필드와 용어만 저장한다.            |
|     with_positions      |      용어, 용어의 시작과 끝 위치를 저정한다.       |
|      with_offsets       |         용어, 문자 오프셋을 저정한다.          |
| with_positions_offsets  | 용어, 용어의 시작과 끝 위치, 문자 오프셋을 모두 저장한다. |

## 3.2 메타 필드
- 메타 필드는 엘라스틱서치에서 생성한 문서에서 제공하는 특별한 필드.
- 매타데이터를 저장하는 특수 목적의 필드로서 이를 이용하면 검색 시 문서를 다양한 형태로 제어하는 것이 가능해진다.
- 색인된 문서를 조회한 예.
~~~
{
  "_index" : "movie_search",
  "_type" : "_doc",
  "_id" : "8",
  "_score":1,
  "_source" : { 
    "movieCd" : "20178401",
    "movieNm" : "검객",
    "prdtYear" : "2017",
    "openDt" : "",
    "typeNm" : "장편",
    "prdtStatNm" : "후반작업",
    "nationAlt" : "한국",
    "genreAlt" : "사극, 액션"
  }
}
~~~
- 실제 문서의 정보를 담고 있는 항목은 _score 항목이다. 그 밖에 _index, _type, _id, _score항목이 엘라스틱서치가 직접 생성한 메타 필드.
- 이번 장에서는 메타필드에 대해 알아본다.

### 3.2.1 _index 메타 필드
- _index 메타 필드는 해당 문서가 속한 인덱스의 이름을 담고 있다. 이를 이용해 검색된 문서의 인덱스명을 알 수 있으며, 해당 인덱스에 몇 개의 문서가 있는지 확인할 수 있다.
- 집계 API를 이용해 다음과 같이 실행해보자.

~~~
POST movie_search/_search
{
  "size":0,
  "aggs" : {
    "indices":{
      "terms": {
        "field":"_index",
        "size":10
      }
    }
  }
}
~~~
- 그 결과, 인덱스별 카운트 정보를 확인할 수 있다.
~~~
{
  (...생략...)
  
  "aggregations": {
    "indices" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count": 0,
      "bucket" : [
        {
          "key" : "movie_search",
          "doc_count" : 29507
        }
      ]
    }
  }
}
~~~

### 3.2.2 _type 메타 필드
- _type 메타필드는 해당 문서가 속한 매핑의 타입 정보를 담고 있다. 이를 이용해 해당 인덱스 내부에서 타입별로 몇 개가 있는지 확인할 수 있다.
- 집계 API를 이용해 다음과 같이 실행해보자
~~~
POST movie_search/_search
{
  "size": 0,
  "aggs": {
    "indices": {
      "terms": {
        "field": "_type",
        "size": 10
      }
    }
  } 
}
~~~
- 결과로 타입별 카운트 정보를 확인할 수 있다.
~~~
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 0,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "indices" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [ {
        "key" : "_doc",
        "doc_count":29507
      }]
    }
  }
}

~~~

### 3.2.3 _id 메타 필드
- _id 메타 필드는 문서를 식별하는 유일한 키 값이다. 한 인덱스에서 색인된 문서마다 서로 다른 키 값을 가진다. 집계 api를 이용해 다음과 같이 검색 질의를 하면 키 값에 대응아는 모든 문서가 출력된다.
~~~
POST movie_search/_search
{
  "size": 0,
  "aggs": {
    "indices": {
      "terms": {
        "field": "_id",
        "size": 10
      }
    }
  }
}
~~~
- 결과로 Id별 카운트 정보를 확인할 수 있다.(근데 왜 안됨..?)
~~~
{
(...생략...)

  "aggregations" : {
    "indices" : {
      "doc_count_error_upper_bound" : 5,
      "sum_other_doc_count" : 29497,
      "buckets" : [ {
        "key" : "20173732",
        "doc_count":1
      }, {
        ..등등
      }
      
      ]
    }
  }
}
~~~

### 3.2.4 _uid 메타 필드 
- _uid 메타 필드는 특수한 목적의 식별키다. "#" 태그를 사용해 _type과 _id값을 조합해 사용한다.
- 하지만 내부적으로만 사용되기 때문에 검색 시 조회되는 값은 아니다.
~~~
POST movie_search/_search
{
  "size": 0,
  "aggs": {
    "indices": {
      "terms": {
        "field": "_uid",
        "size": 10
      }
    }
  }
}

{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 0,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "indices" : {
      "doc_count_error_upper_bound" : 5,
      "sum_other_doc_count" : 29497,
      "buckets" : [
        {
          "key" : "_doc#20173732",
          "doc_count" : 1
        },
         {etc..}
        ...etc...
       ]
    }
  }
}
~~~

### 3.2.5 _source 메타필드
- _source 메타 필드는 문서의 원본 데이터를 제공한다. 내부에는 색인 시 전달된 원본 JSON 문서의 본문이 저장돼 있다. 
- 일반적으로 원본 JSON 문서를 검색 결과로 표시할 때 사용한다.
- _reindex API나 스크립트 사용해 해당 값을 계산할 때 해당 메타 필드를 활용할 수 있다.
- ex) movie_search 인덱스에 있는 문서 중 movieCd 값이 "20173732"인 값만 조회해서 재색인한다고 가정했을 때 재색인되는 인덱스에서 prdtYear 값을 변경해 보겠다.

~~~
PUT /reindex_movie
~~~
- 재색인할 인덱스가 생성되면 reIndex API를 이용해 재색인을 수행한다. prdtYear 값을 변경하기 위해 필드에 접근할 표기ㅓㅂㅂ이 필요한데, 
- 이때 스크립트를 이용해 ctx._source.prdtYear형태로 prdtYear 필드에 접근할 수 있다.

~~~
POST /_reindex
{
  "source": {
    "index": "movie_search",
    "query": {
      "match": {
        "movieCd": "20173732"
      }
    }
  },
  "dest": {
    "index": "reindex_movie"
  },
  "script": {"source": "ctx._source.prdtYear++"}
  
}

{
  "took" : 18,
  "timed_out" : false,
  "total" : 0,
  "updated" : 0,
  "created" : 0,
  "deleted" : 0,
  "batches" : 0,
  "version_conflicts" : 0,
  "noops" : 0,
  "retries" : {
    "bulk" : 0,
    "search" : 0
  },
  "throttled_millis" : 0,
  "requests_per_second" : -1.0,
  "throttled_until_millis" : 0,
  "failures" : [ ]
}

~~~

- 재색인할 때 스크립트로 prdtYear 필드에 1을 더했다. 재색인되는 인덱스의 필드 데이터 타입이 keyword로 자동 생성되므로 문자열 형태로 1이 더해질 것이다.
- 다음 두 문서를 비교해보면 prdtYear 값의 차이점을 확인할 수 있다.

~~~
POST reindex_movie/_search
{
  "query": {
    "term": {
      "moiveCd": "20173732"
    }
  }
} 

결과 prdtYear에 "20171"로 변경됨.... 
~~~

### 3.2.6 _all 메타 필드
- _all 메타 필드는 데이터 크기를 너무 많이 차지하는 문제가 있어 엘라스틱서치 6.0부터는 폐기
- 필드 복사가 필요할 경우 copy_to 파라미터를 사용해야 한다. copy_to를 이용하면 _all과 동일한 효과를 낼 수 있다.

### 3.2.7 _routing 메타 필드
- _routing 메타 필드는 특정 무서를 특정 샤드에 저장하기 위해 사용자가 지정하는 메타 필드다. 기본적으로 색인을 하면 해당 문서는 다음 수식에 따라 문서 id를 이용해 문서가 색인될 샤드를 결정한다.
- 별도의 설정 없이 문서를 색인하면 문서는 샤드에 골고루 분산되어 저장한다.
~~~
Hash (documnt_id) % num_of_shards
~~~
- 특정 문서들을 하나의 샤트에 저장하고 싶을 때 _routing 메타 필드를 사용할 수 있다. 
- 문서 ID를 사용하는 대신 파라미터로 입력한 _routing 값이 샤드를 결정하는데 사용한다.
~~~
Hash (_routing) % num_of_shards
~~~
- ex) _routing 값을 ko로 지정해 문서 색인

~~~
PUT movie_routing/_doc/1?routing=ko
{
  "repGenreNm":"한국어",
  "movieNm":"살아남은 아이"
}

//색인 문서 정보 확인
POST movie_routing/_doc/_search?routing=ko 

--> 

{
  "error" : {
    "root_cause" : [
      {
        "type" : "parse_exception",
        "reason" : "request body is required"
      }
    ],
    "type" : "parse_exception",
    "reason" : "request body is required"
  },
  "status" : 400
}
????

#결과
"hits" : {
  "total" : 3,
  "max_score" :1.0,
  "hits" : [
    {
      "_index" : "movie_routing",
      "_type" : "_doc",
      "_id":"1",
      "_score":1.0,
      "_routing":"ko",
      "_score":{
        "repGenreNm":"한국어",
        "movieNm":"살아남은 아이"
      }
    }
  ]
}
~~~

## 3.3 필드 데이터 타입
- 필드에는 다음과 같은 데이터 타입을 지정할 수 있다.
  - keyword, text같은 문자 데이터 타입
  - date, long, double, integer, boolean, ip 같은 일반적인 데이터 타입
  - 객체 또는 중첩문과 같은 JSON 계층의 특성의 데이터 타입
  - geo_point, geo_shape 같은 특수한 데이터 타입

### 3.3.1 Keyword 데이터 타입
- Keyword 데이터 타입은 키워드 형태로 사용할 데이터에 적합한 데이터 타입.
- 별도의 분석기를 거치지 않고 원문 그대로 색인하기 떄문에 특정 코드나 키워드 등 정형화된 콘텐츠에 주로 사용
- 엘라스틱서치의 일부 기능은 형태소 분석을 하지 않아야만 사용이 가능한데 이 경우에도 Keyword 데이터 타입이 사용
- ex) Keyword 데이터 타입을 사용
~~~
PUT movie_search_datatype/_mapping/_doc
{
  "properties" : {
    "multiMovieYn" : {
      "type":"keyword"
    }
  }
}

#???
{
  "error" : "no handler found for uri [/movie_search_datatype/_mapping/_doc?pretty=true] and method [PUT]"
}
~~~
- Keyowrd 데이터 타입은 아래에 해당하는 항목에 사용
  - 검색시 필터링되는 항목
  - 정렬 필요 항목
  - 집계해야 하는 항목
- 'elastic search'라는 문자열이 Keyword타입으로 설정되면 'elastic', 'search' 질의로는 검색 안됨(반드시 'elastic search'로 질의)
- Keyword 타입에서 설정 가능한 주요 파라미터

  |     -      |                                                                            -                                                                            |
  |:----------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------:|
  |   boost    | 필드의 가중치로, 검색 결과 정렬에 영향을 준다. 기본값은 1.0으로서 1보다크면 Score가 높게 오르고, 저긍면 점수가 낮게오른다.<br/>이를 이용해 검색에 사용된 키워드와 문서 간의 유사도 스코어 값을 계산할 때 필드의 가중치 값을 얼마나 더 줄것인지를 판단한다. |
  | doc_values |                                                            필드를 메모리에 로드해 캐시로 사용한다. 기본값은 true                                                             |
  |   index    |                                                            해당 필드를 검색에 사용할지를 설정한다. 기본값은 true                                                             |
  | null_value |                                     기본적으로 엘라스틱서치는 데이터의 값이 없으면 필드를 생성하지 않는다. 데이터의 값이 없는 경우 null로 필드의 값을 대체할지를 설정한다.                                      |
  |   store    |                                                필드 값을 필드와 별도로 _source에 저장하고 검색 가능하게 할지를 설정한다. 기본값은 false                                                 |

### 3.3.2 Text 데이터 타입
- 색인 시 지정된 분석기가 칼럼의 데이터를 문자열 데이터로 인식하고 이를 분석
- 별도의 분석기 미정의시 기본적으로 Standard Analyzer 사용
- 문장 형태의 데이터 사용에 적합
- 전문 검색 가능 전체 텍스트가 토큰화되어 생성되며 특정 단어 검색 가능.
- ex) Text 데이터 타입을 사용하는 예
~~~
PUT movie_text/_mapping/_doc
{
  "properties" : {
    "movieComment": {
      "type":"text"
    }
  }
}
~~~
- Text 데이터 타입을 사용할 경우 필드에 검색뿐아니라 정렬이나 집계 연산을 사용해야 할 대가 있다. 이러한 경우 Text타입과 Keyword 타입을 동시에 갖도록 멀티 필드 설정
- movieComment필드는 Text 타입으로 지정됐으나, 필드 하위에 movieComment_keword라는 Keyword타입의 필드를 하나 더 가지고 있다.
- 하나의 필드를 용도에 맞게 각기 다른 형태로 활용
~~~
PUT movie_text/_mapping/_doc
{
  "properties" : {
    "movieComment": {
      "type":"text",
      "fields": {
        "movieComment_keyword":{
          "type":"keyword"
        }
      }
    }
  }
}
~~~
- Text 타입에서 설정 가능한 주요 파라미터

|        -        |                                     -                                     |
|:---------------:|:-------------------------------------------------------------------------:|
|    analyzer     |            인덱스와 검색에 사용할 형태소 분석기를 선택한다. 기본값은 Standard Analyzer             |
|      boost      | 필드의 가중치로, 검색 결과 정렬에 영향을 준다. 기본값은 1.0으로 1보다 크면 점수가 높게 오르고, 적으면 점수가 낮게 오른다. |
|    fielddata    |         정렬, 집계, 스크립트 등에서 메모리에 저장된 필드 데이터를 사용할지를 설정한다. 기본값은 false          |
|      index      |                     해당 필드를 검색에 사용할지를 설정한다. 기본값은 true                      |
|      norms      |                     유사도 점수를 산정할 때 필드 길이를 고려할지를 결정한다.                      |
|      store      |         필드 값을 필드와 별도로 _source에 저장하고 검색 가능하게 할지를 설정한다. 기본값은 false          |
| search_analyzer |                          검색에 사용할 형태소 분석기를 선택한다.                           |
|   similarity    |                     유사도 점수를 구하는 알고리즘을 선택한다. 기본값은 BM25                     |
|   term_vector   |                   Analyzed 필드에 텀벡터를 저장할지를 결정한다. 기본값은 no                   |

### 3.3.3 Array 데이터 타입
- Array 타입은 문자열이나 숫자처럼 일반적인 값을 지정할 수도 있지만 객체 형태로도 정의할 수 있다.
- 주의) 모두 같은 타입으로만 구성해야 한다.
  - 문자열 배열 ["one", "two"]
  - 정수 배열 [1, 2]
  - 객체 배열 [{"name" : "Mary", "age" : 12}, {"name" : "John", "age" : 11}]
- 엘라스틱서치에서는 매핑 설정 시 Array 타입을 명시적으로 정의하지 않는다. 
- 인덱스 필드에 배열 값을 입력하면 자동으로 Array 형태로 저장.
- 동적으로 추가되면 첫번째 값이 필드의 데이터 타입 결정. (모두 같아야 한다.)
- ex) Array 데이터 타입을 사용
~~~
PUT movie_search_datatype/_doc/1
{
  "title" : "해리포터와 마법사의 돌", 
  "subtitleLang" : ["ko", "en"]
}
~~~
### 3.3.4 Numeric 데이터 타입
- 엘라스틱서치에서는 숫자 데이터 타입은 여러 가지 종류가 제공된다(색인과 검색을 효율적으로 처리하기 위해)

|     -      |                          -                           |
|:----------:|:----------------------------------------------------:|
|    long    | 최솟값과 최댓값을 가지는 부호 있는 64비트 정수. 범위는 [-2^63 ~ 2^63 - 1]  |
|  integer   | 최솟값과 최댓값을 가지는 부호 있는 32비트 정수. 범위는 [-2^31 ~ 2^631 - 1] |
|   short    | 최솟값과 최댓값을 가지는 부호 있는 16비트 정수. 범위는 [-32,768 ~ 32,767]  |
|    byte    |     최솟값과 최댓값을 가지는 부호 있는 8비트 정수. 범위는 [-128 ~ 127]     |
|   double   |                  64비트 부동 소수점을 갖는 수                   |
|   float    |                  32비트 부동 소수점을 갖는 수                   |
| half_float |                  16비트 부동 소수점을 갖는 수                   |

~~~
PUT movie_text/_mapping/_doc
{
  "properties" : {
    "year" : {
      "type" : "integer"
    }
  }
}
~~~

### 3.3.5 Date 데이터 타입
- 기본 형식 : "yyyy-MM-ddTHH:mm:ssZ"
- Date 타입은 세가지 형태 제공 어느것을 사용해도 내부적으로 UTC의 밀리초 단위로 변환해 저장한다.
  - 문자열이 포함된 날짜 형식 : "2018-04-20","2018/04.20","2018-04-20 15:00:00", "2018/04/20 10:50:00"
  - ISO_INSTANT 포맷의 날짜 형식 : "2018-04-10T10:50:00Z"
  - 밀리초:1524449145579
- ex) Date 데이터 타입 사용
~~~
PUT movie_text/_mapping/_doc
{
  "date": {
    "type": "date",
    "format": "yyyy-MM-dd HH:mm:ss"
  }
}
~~~
