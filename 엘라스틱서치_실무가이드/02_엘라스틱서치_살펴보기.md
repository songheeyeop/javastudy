# 01 엘라스틱서치 살펴보기
- 엘라스틱서치
  - 솔라, 루씬의 자리를 대체
  - 루씬 기반의 검색엔진으로서 실시간에 가까운 전문 검색
  - 멀티테넌시 지원
  - NoSQL 저장소의 역하띾지 담당
  - 단순한 검색엔진을 넘어 데이터 수집부터 저장, 분석, 시각화에 이르는 다양한 분야의 데이터 분석 도구로서 주목

## 2.1 엘라스틱서치를 구성하는 개념
- 엘라스틱서치는 기본적으로 분산 시스템을 지향
- 엘라스틱서치를 구성하는 주요 구성요소로 어떤 것이 있는지 다양한 개념들은 먼저 알아봄

### 2.1.1 기본 용어
- 엘라스틱서치의 데이터는 다음 그림과 같이 인덱스, 타입, 문서, 필드 구조로 구성
- 그림 2.1 데이터의 구조
![데이터의 구조](/image/img_2.png)
- 인덱스
  - 데이터 저장 공간.
  - 하나의 인덱스는 하나의 타입만 가지며 하나의 물리적인 노드에 여러 개의 논리적인 인덱스를 생성할 수 있다.
  - 검색 시 인덱스 일므으로 문서 데이터를 검색하며, 여러 개의 인덱스를 동시에 검색하는 것도 가능하다.
  - 엘라스틱서치를 분산 환경으로 구성화면 하나의 인덱스가 여러 노드에 분산 저장되어 관리된다.
  - 따라서 분산 처리에 따른 여러 이점을 누릴 수 있다. 
  - 엘라스틱 서치는 인덱스 생성 시 기본적으로 5개의 프라이머리 샤드와 1개의 레플리카 샤드 세트를 생성한다.
  - 각각의 샤드 수는 인덱스를 생성할 때 옵션을 이용해 변경할 수 있다. 
  - 인덱스의 이름은 모두 소문자여야 하며 추가, 수정, 삭제, 검색은 RESTful API로 수행가능. 
  - 만약 인덱스가 없는 상태에서 데이터가 추가된다면 데이터를 이용해 인덱스가 자동으로 생성된다.
- 샤드
  - 색인된 문서는 하나의 인덱스에 담긴다.
  - 인덱스 내부에 색인된 데이터는 물리적인 공간에 여러 개의 파티션으로 나뉘어 구성되는데, 이 파티션을 엘라스틱서치에서는 샤드라고 부른다. 
  - 엘라스틱서치는 다수의 샤드로 문서를 분산 저장하고 있어 데이터 손실 위험을 최소화할 수 있다.
- 타입
  - 타입은 인덱스의 논리적 구조를 의미하며, 인덱스 속서엥 따라 분류하기도 한다.
  - 6.1 버전부터는 인덱스당 하나의 타입만 사용할 수 있다.
- 문서
  - 문서는 엘라스틱서치에서 데이터가 저장되는 최소 단위다. 
  - 기본적으로 JSON 포맷으로 데이터가 저장된다.
  - 데이터베이스의 테이블의 행 = 엘라스틱서치의 문서
  - 하나의 문서는 다수의 필드로 구성돼 있는데 각 필드는 데이터의 형태에 따라 용도에 맞는 데이터 타입을 정의해야 한다.
  - 문서는 중첩 구조를 지원하기 때문에 이를 이용해 문서 안에 문서를 지정하는 것도 가능하다.
- 필드
  - 필드는 문서를 구성하기 위한 속성
  - 일반적으로 데이터베이스의 컬럼과 비교할 수 있으나, 컬럼이 정적인 데이터 타입인데 반해 필드는 좀 더 동적인 데이터 타입
  - 하나의 필드는 목적에 따라 다수의 데이터 타입을 가질 수 있다. 
  - 영화 정보를 담아둔 문서에 제목 필드가 있을 경우 영화 제목을 검색할 때 매칭 검색을 하거나 초성을 이용한 검색이 모두 지원되도록 제목 필드는 2개의 데이터 타입을 가져야 한다.
- 매핑
  - 매핑은 문서의 필드와 필드의 속성을 정의하고 그에 따른 색인 방법을 정의하는 프로세스다.
  - 인덱스의 매핑 정보에는 여러가지 데이터 타입을 지정할 수 있지만 필드명은 중복해서 사용할 수 없다.

### 2.1.2 노드의 종류
- 클러스터는 물리적인 노드 인스턴스들의 모임
- 클러스터는 모든 노드의 검색과 색인 작업을 관장하는 논리적인 개념
- RDBMS의 경우 모든 요청을 서버 하나에서 처리해서 결과를 제공하지만 엘라스틱서치의 경우에는 다수의 서버로 분산해서 처리하는 것이 가능하기 때문에 대용량 데이터 처리 가능
- 분산 처리를 위해서는 다양한 형태의 노드들을 조합해서 클러스터를 구성해야 한다.
- 기본적으로 마스터 노드가 전체적인 클러스터를 관리하고 데이터 노드가 실제 데이터를 관리
- 엘라스틱서치는 각 설정에 따라 4가지 유형의 노드를 제공
  - 마스터 노드
    - 클러스터를 관리.
    - 노드 추가와 제거 같은 클러스터의 전반적인 관리 담당
  - 데이터 노드
    - 실질적인 데이터 저장
    - 검색과 통계 같은 데이터 관련 작업 수행
  - 코디네이팅 노드
    - 사용자의 요청만 받아서 처리
    - 클러스터 관련 요청은 마스터 노드에 전달하고 데이터 관련 요청은 데이터 노드에 전달
  - 인제스트 노드
    - 문서의 전처리 작업을 담당
    - 인덱스 생성 전 문서의 형색을 다양하게 변경 할 수 있다.
- 설정에 따라 각 노드는 한가지 유형으로 동작할 수도 있고 여러 개의 유형을 겸해서 동작할 수도 있다.
- 마스터노드
  - 마스터 노드는 인댁스를 생성, 삭제하는 등 클러스터와 관련된 전반적은 작업을 담당
  - 네트워크 속도가 빠르고 지연이 없는 노드를 마스터 노드로 선정해야 한다.
  - 다수의 노드를 마스터 노드로 설정할 수 있지만 결과적으로 하나의 노드만이 마스터 노드로 선출되어 동작.
  - 노드를 마스터 노드 전용으로 설정하고자 않다면 엘라스틱서치 서버의 conf폴더 안의 elasticsearch.yml 파일을 열고 다음과 같이 설정하면 된다.
~~~
node.master: true
node.data: false
node.ingest: false
search.remove.connect: false
~~~
- 데이터 노드
  - 데이터 노드는 문서가 실제로 저장되는 노드
  - 데이터가 실제로 분산 저장되는 물리적 공간인 샤드가 배치되는 노드
  - 색인 작업은 CPU, 매모리, 스토리지 같은 컴퓨팅 리소스를 많이 소모하기 때문에 리소스 모니터링이 필요
  - 데이터 노드는 가능한 한 마스터 노드와 분리해서 구성하는게 좋다. 
  - 색인할 문서의 수가 적으면 함께 구성해도 상관 없음
  - elasticsearch.yml 파일을 다음과 같이 수정하면 데이터 노드 전용으로 설정할 수 있다.
~~~
node.master: false
node.data: true
node.ingest: false
search.remove.connect: false
~~~
- 코디네이팅 노드
  - 데이터 노드, 마스터 노드, 인제스트 노드의 역할을 하지 않고, 들어온 요청을 단순히 라운드로빈 방식으로 분산시켜 주는 노드
  - 구성 방법
~~~
node.master: false
node.data: false
node.ingest: false
search.remove.connect: false
~~~
- 인제스트 노드
  - 색인에 앞서 데이터를 전처리하기 위한 노드
  - 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다.
  - 구성 방법
~~~
node.master: false
node.data: false
node.ingest: true
search.remove.connect: false
~~~
### 2.1.3 클러스터, 노드, 샤드
- 그림 2.2 클러스터와 노드
  ![클러스터와 노드](/image/img_3.png)
- 하나의 엘라스틱서치 클러스터에 노드#1, 노드#2로 총 2개의 물리적 노드가 존재한다. 
- 엘라스틱서치 클러스터는 인덱스의 문서를 조회할 때 마스터 노드를 통해 2개의 노드를 모두 조회해서 각 데이터를 취합한 후 결과를 하나로 합쳐서 제공한다.
- 여러개의 클러스터를 연결해서 고성도 가능 이때는 클러스트의 이름으로 각각 구분한다
- 만약 클러스터의 이름이 명시적으로 설정되지 않았다면 엘라스틱서치는 클러스터의 이름을 임의의 문자열로 지정한다.
- 또한 클러스터에 있는 노드는 실시간으로 추가, 제거가 가능하기 때문에 가용성이나 확장성 측면에서 매우 유연하다.
- 테스트
  - 클러스터는 3개의 노드로 구성했다고 가정
  - 프라이머리 샤드와 레플리카 샤드의 수를 조정해가며 인덱스 생성 시 클러스터의 동작을 살펴봄
  - <strong>프라이머리 샤드 3개, 레플리카 샤드 0세트 구성</strong>
    - 첫 구성은 프라이머리 샤드 3개, 레플리카 샤드 0개이다.
~~~
{
  "settings" : {
    "index" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 0
    }
  }
}
~~~
- 
  - 
    - 인덱스의 이름은 starwars이며, 노드는 data-node-01, data-node-02, data-node-03으로 총 3개다 .
    - 그림 2.3 프라이머리 샤드 3개, 레플리카 샤드 0개로 구성
    - 
      ![그림 2.3](/image/img_4.png)
    - 이 그림에서 우측의 숫자 막스가 의미하는 것이 샤드다. 샤드는 분산된 데이터에 따라 순차적인 번호를 가진다.
    - 일반적으로 프라이머리 샤드는 안정성을 위해 하나의 노드에 하나씩 분산 저장된다. 인덱스에 다수의 문서를 색인하게 되면 문서는 3개의 샤드로 골고루 분산 저장된다.
  - <strong>프라이머리 샤드 6개, 레플리카 샤드 0세트 구성</strong>
~~~
{
  "settings" : {
    "index" : {
      "number_of_shards" : 6,
      "number_of_replicas" : 0
    }
  }
}
~~~
- 
  - 
    - 테스트를 위해 starwars 인덱스를 삭제한 후 재생성했다.
    - 그림 2.4 프라이머리샤드 6개, 레플리카 샤드 0개로 구성
    - 
      ![그림 2.4](/image/img_4.png)
    - 3개의 노드에 프라이머드 샤드 6개가 2개씩 배치됐다. 색인 시 6개의 샤드에 데이터가 분산된다.
    - 앞선 구성보다 프라이머리 샤드의 수가 2배 많기 때문에 데이터가 더 잘게 쪼개져서 저장
  - <strong>프라이머리 샤드 3개, 레플리카 샤드 1세트 구성</strong>
    - 레플리카 샤드는 프라이머리 샤드의 복제본이다. 예제에서는 레플리카 샤드 1세트를 설정했으므로 3개의 레플리카 샤드가 생성된다.
~~~
{
  "settings" : {
    "index" : {
      "number_of_shards" : 6,
      "number_of_replicas" : 0
    }
  }
}
~~~
- 
  - 
    - 엘라스틱서치는 장애 시 레플리카 샤드를 이용해 샤드를 복구한다. 따라서 다음 그림처럼 번호가 같은 프라이머리 샤드와 레플리카 샤드가 서로 다른 노드에 배치된다.
    - 그림 2.5 프라이머리 샤드 3개, 레플리카 샤드 3개로 구성
    - 
      ![그림 2.5](/image/img_4.png)
    - 프라이머리 샤드만 3개로 구성한 첫 번째 예제와 달리 각 노드에 점선 박스가 하나씩 더 존재한다.
    - 이 박스가 바로 레플리카 샤드를 의미한다. 플라이머리 샤드는 복사본이 존재하기 때문에 물리적인 노드 하나가 죽더라도 나머지 노드 2개가 전체 데이터를 복구할 수 있다.  (??? 이게 무슨 말일까요 노드 2에는 샤드가 2개라 복구가 가능하단건가??)
    - 장애가 발생하면 마스터 노드는 데이터를 재분배하거나 레플리카 샤드를 프라이머리 샤드로 승격시켜 서비스 중단 없는 복구가 가능해진다. 
    - 따라서 장애극복 상황을 염두에두고 노드와 샤드 수를 적절히 구성해야 한다.
## 2.2 엘라스틱서치에서 제공하는 주요 API 
- API의 종류
  - 엘라스틱서치에서는 다음과 같은 주요 API 제공
    - 인덱스 관리 API : 인덱스 관리
    - 문서 관리 API: 문서의 추가/수정/삭제
    - 검색 API : 문서 조회
    - 집계 API : 문서 통계
  - 문서를 색인하기 위해서는 기본적으로 인덱스라라는 그릇을 생성해야 한다.
  - 인덱스를 통해 입력되는 문서의 필드 정의하고 각 필으데 알맞은 데이터 타입 지정할 수 있다.
  - 이러한 과정을 통해 좀 더 효율적인 색인 가능
  - Index vs Indices
    - 엘라스틱서치를 공부하다 보면 용어가 아리송한 경우가 종종 있다. 대표적인 용어가 "색인".
    - 색인은 데이터가 토큰화되어 저장된 자료구조 = Index
    - 엘라스틱서치에서는 인덱스라는 용어를 색인과는 다른 의미로 사용
      - Index : 색인 데이터 
      - Indexing : 색인하는 과정
      - Indices : 매핑 정보를 저장하는 논리적인 데이터 공간.
    - 엘라스틱서치에서는 용어에 따른 혼란을 방지하기 위해 색인을 의마할 경우 "Index"라는 단어를 사용하고, 매핑 정의 공간을 의미할 경우 "Indices"라는 단어로 표현.
    - 한글로 "인덱스" = "Indeces" 번역.
  - 엘라스틱서치 사용 편의성을 위해 스키마리스라는 기능을 제공
  - 문서를 색인하기 위해서는 기본적으로 인덱스를 생성하는 과정 필요, 인덱스를 생성하는 과정 없이 문서를 추가하더라도 문서가 색인되도록 지원하는 일종의 편의 기능
  - 엘라스틱서치는 최초 문서가 색인될 때 인덱스의 존재 여부를 확인하고 만약 인덱스가 존재하지 않는다면 문서를 분석해서 문서가 색인될 수 있게 인덱스를 자동으로 생성한다.
- 스키마리스 기능은 가급적이면 사용하지 말자
  - 스키마리스 기능은 성능과 밀접한 연관이 있기 때문에 특수한 상황에서만 사용해야 한다.
  - 스키마리스를 사용해야 한다면 데이터 구조 및 검색 방식을 확실히 이해해야 한다.
  - 테스트를 위해 인덱스를 생성하지 않고 바로 데이터를 색인해보자.
  - 데이터 추가와 동시에 인덱스가 생성되는 스키마리스 예제다. 
  - 인덱스 매핑 정보가 정의되지 않았기 때문에 JSON 형식의 키-값을 분석해서 필드명과 각종 속성 정보를 자동으로 생성한다.
  - 다음 명령어의 실행 및 결과
~~~
PUT /movie/_doc/1
{
  "movieCd":"1",
  "movieNm":"살아남은 아이",
  "movieNmEn":"Last Child",
  "prdtYear":"2017",
  "openDt":"",
  "typeNm":"장편",
  "prdtStatNm":"기타",
  "nationAlt":"한국",
  "genreAlt":"드라마, 가족",
  "repNationNm":"한국",
  "repGenreNm":"드라마"
}


{
  "_index" : "movie",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : "1",
  "result" : "created",
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
~~~
- 
  - 결과를 살펴보면 5개의 샤드로 구성된 movie인덱스 생성
  - _id가 1인 문서 추가
  - 문제점
    - 인덱스가 자동으로 생성되어 세부적인 필드 정보가 매핑되지 않음
  - 인덱스를 자동으로 생성할 경우 특정 단어 검색 시 검색 결과에서 누락되는 등 문제가 발생할 가능성이 높아진다.
- 