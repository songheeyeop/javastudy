# 01 엘라스틱서치 살펴보기
- 엘라스틱서치
  - 솔라, 루씬의 자리를 대체
  - 루씬 기반의 검색엔진으로서 실시간에 가까운 전문 검색
  - 멀티테넌시 지원
  - NoSQL 저장소의 역하띾지 담당
  - 단순한 검색엔진을 넘어 데이터 수집부터 저장, 분석, 시각화에 이르는 다양한 분야의 데이터 분석 도구로서 주목

## 2.1 엘라스틱서치를 구성하는 개념
- 엘라스틱서치는 기본적으로 분산 시스템을 지향
- 엘라스틱서치를 구성하는 주요 구성요소로 어떤 것이 있는지 다양한 개념들은 먼저 알아봄

### 2.1.1 기본 용어
- 엘라스틱서치의 데이터는 다음 그림과 같이 인덱스, 타입, 문서, 필드 구조로 구성
- 그림 2.1 데이터의 구조
![데이터의 구조](/image/img_2.png)
- 인덱스
  - 데이터 저장 공간.
  - 하나의 인덱스는 하나의 타입만 가지며 하나의 물리적인 노드에 여러 개의 논리적인 인덱스를 생성할 수 있다.
  - 검색 시 인덱스 일므으로 문서 데이터를 검색하며, 여러 개의 인덱스를 동시에 검색하는 것도 가능하다.
  - 엘라스틱서치를 분산 환경으로 구성화면 하나의 인덱스가 여러 노드에 분산 저장되어 관리된다.
  - 따라서 분산 처리에 따른 여러 이점을 누릴 수 있다. 
  - 엘라스틱 서치는 인덱스 생성 시 기본적으로 5개의 프라이머리 샤드와 1개의 레플리카 샤드 세트를 생성한다.
  - 각각의 샤드 수는 인덱스를 생성할 때 옵션을 이용해 변경할 수 있다. 
  - 인덱스의 이름은 모두 소문자여야 하며 추가, 수정, 삭제, 검색은 RESTful API로 수행가능. 
  - 만약 인덱스가 없는 상태에서 데이터가 추가된다면 데이터를 이용해 인덱스가 자동으로 생성된다.
- 샤드
  - 색인된 문서는 하나의 인덱스에 담긴다.
  - 인덱스 내부에 색인된 데이터는 물리적인 공간에 여러 개의 파티션으로 나뉘어 구성되는데, 이 파티션을 엘라스틱서치에서는 샤드라고 부른다. 
  - 엘라스틱서치는 다수의 샤드로 문서를 분산 저장하고 있어 데이터 손실 위험을 최소화할 수 있다.
- 타입
  - 타입은 인덱스의 논리적 구조를 의미하며, 인덱스 속서엥 따라 분류하기도 한다.
  - 6.1 버전부터는 인덱스당 하나의 타입만 사용할 수 있다.
- 문서
  - 문서는 엘라스틱서치에서 데이터가 저장되는 최소 단위다. 
  - 기본적으로 JSON 포맷으로 데이터가 저장된다.
  - 데이터베이스의 테이블의 행 = 엘라스틱서치의 문서
  - 하나의 문서는 다수의 필드로 구성돼 있는데 각 필드는 데이터의 형태에 따라 용도에 맞는 데이터 타입을 정의해야 한다.
  - 문서는 중첩 구조를 지원하기 때문에 이를 이용해 문서 안에 문서를 지정하는 것도 가능하다.
- 필드
  - 필드는 문서를 구성하기 위한 속성
  - 일반적으로 데이터베이스의 컬럼과 비교할 수 있으나, 컬럼이 정적인 데이터 타입인데 반해 필드는 좀 더 동적인 데이터 타입
  - 하나의 필드는 목적에 따라 다수의 데이터 타입을 가질 수 있다. 
  - 영화 정보를 담아둔 문서에 제목 필드가 있을 경우 영화 제목을 검색할 때 매칭 검색을 하거나 초성을 이용한 검색이 모두 지원되도록 제목 필드는 2개의 데이터 타입을 가져야 한다.
- 매핑
  - 매핑은 문서의 필드와 필드의 속성을 정의하고 그에 따른 색인 방법을 정의하는 프로세스다.
  - 인덱스의 매핑 정보에는 여러가지 데이터 타입을 지정할 수 있지만 필드명은 중복해서 사용할 수 없다.

### 2.1.2 노드의 종류
- 클러스터는 물리적인 노드 인스턴스들의 모임
- 클러스터는 모든 노드의 검색과 색인 작업을 관장하는 논리적인 개념
- RDBMS의 경우 모든 요청을 서버 하나에서 처리해서 결과를 제공하지만 엘라스틱서치의 경우에는 다수의 서버로 분산해서 처리하는 것이 가능하기 때문에 대용량 데이터 처리 가능
- 분산 처리를 위해서는 다양한 형태의 노드들을 조합해서 클러스터를 구성해야 한다.
- 기본적으로 마스터 노드가 전체적인 클러스터를 관리하고 데이터 노드가 실제 데이터를 관리
- 엘라스틱서치는 각 설정에 따라 4가지 유형의 노드를 제공
  - 마스터 노드
    - 클러스터를 관리.
    - 노드 추가와 제거 같은 클러스터의 전반적인 관리 담당
  - 데이터 노드
    - 실질적인 데이터 저장
    - 검색과 통계 같은 데이터 관련 작업 수행
  - 코디네이팅 노드
    - 사용자의 요청만 받아서 처리
    - 클러스터 관련 요청은 마스터 노드에 전달하고 데이터 관련 요청은 데이터 노드에 전달
  - 인제스트 노드
    - 문서의 전처리 작업을 담당
    - 인덱스 생성 전 문서의 형색을 다양하게 변경 할 수 있다.
- 설정에 따라 각 노드는 한가지 유형으로 동작할 수도 있고 여러 개의 유형을 겸해서 동작할 수도 있다.
- 마스터노드
  - 마스터 노드는 인댁스를 생성, 삭제하는 등 클러스터와 관련된 전반적은 작업을 담당
  - 네트워크 속도가 빠르고 지연이 없는 노드를 마스터 노드로 선정해야 한다.
  - 다수의 노드를 마스터 노드로 설정할 수 있지만 결과적으로 하나의 노드만이 마스터 노드로 선출되어 동작.
  - 노드를 마스터 노드 전용으로 설정하고자 않다면 엘라스틱서치 서버의 conf폴더 안의 elasticsearch.yml 파일을 열고 다음과 같이 설정하면 된다.
~~~
node.master: true
node.data: false
node.ingest: false
search.remove.connect: false
~~~
- 데이터 노드
  - 데이터 노드는 문서가 실제로 저장되는 노드
  - 데이터가 실제로 분산 저장되는 물리적 공간인 샤드가 배치되는 노드
  - 색인 작업은 CPU, 매모리, 스토리지 같은 컴퓨팅 리소스를 많이 소모하기 때문에 리소스 모니터링이 필요
  - 데이터 노드는 가능한 한 마스터 노드와 분리해서 구성하는게 좋다. 
  - 색인할 문서의 수가 적으면 함께 구성해도 상관 없음
  - elasticsearch.yml 파일을 다음과 같이 수정하면 데이터 노드 전용으로 설정할 수 있다.
~~~
node.master: false
node.data: true
node.ingest: false
search.remove.connect: false
~~~
- 코디네이팅 노드
  - 데이터 노드, 마스터 노드, 인제스트 노드의 역할을 하지 않고, 들어온 요청을 단순히 라운드로빈 방식으로 분산시켜 주는 노드
  - 구성 방법
~~~
node.master: false
node.data: false
node.ingest: false
search.remove.connect: false
~~~
- 인제스트 노드
  - 색인에 앞서 데이터를 전처리하기 위한 노드
  - 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다.
  - 구성 방법
~~~
node.master: false
node.data: false
node.ingest: true
search.remove.connect: false
~~~
### 2.1.3 클러스터, 노드, 샤드
- 그림 2.2 클러스터와 노드
  ![클러스터와 노드](/image/img_3.png)
- 하나의 엘라스틱서치 클러스터에 노드#1, 노드#2로 총 2개의 물리적 노드가 존재한다. 
- 엘라스틱서치 클러스터는 인덱스의 문서를 조회할 때 마스터 노드를 통해 2개의 노드를 모두 조회해서 각 데이터를 취합한 후 결과를 하나로 합쳐서 제공한다.
- 여러개의 클러스터를 연결해서 고성도 가능 이때는 클러스트의 이름으로 각각 구분한다
- 만약 클러스터의 이름이 명시적으로 설정되지 않았다면 엘라스틱서치는 클러스터의 이름을 임의의 문자열로 지정한다.
- 또한 클러스터에 있는 노드는 실시간으로 추가, 제거가 가능하기 때문에 가용성이나 확장성 측면에서 매우 유연하다.
- 테스트
  - 클러스터는 3개의 노드로 구성했다고 가정
  - 프라이머리 샤드와 레플리카 샤드의 수를 조정해가며 인덱스 생성 시 클러스터의 동작을 살펴봄
  - <strong>프라이머리 샤드 3개, 레플리카 샤드 0세트 구성</strong>
  - 첫 구성은 프라이머리 샤드 3개, 레플리카 샤드 0개이다.
~~~
{
  "settings" : {
    "index" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 0
    }
  }
}
~~~

